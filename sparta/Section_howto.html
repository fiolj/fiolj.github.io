

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>6. How-to discussions &mdash; SPARTA 7 May 2020 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/rtd_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="7. Example problems" href="Section_example.html" />
    <link rel="prev" title="5. Accelerating SPARTA performance" href="Section_accelerate.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> SPARTA
          

          
          </a>

          
            
            
              <div class="version">
                7 May 2020
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Section_intro.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="Section_start.html">2. Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="Section_commands.html">3. Commands</a></li>
<li class="toctree-l1"><a class="reference internal" href="Section_packages.html">4. Packages</a></li>
<li class="toctree-l1"><a class="reference internal" href="Section_accelerate.html">5. Accelerating SPARTA performance</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">6. How-to discussions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#d-simulations">6.1. 2d simulations</a></li>
<li class="toctree-l2"><a class="reference internal" href="#axisymmetric-simulations">6.2. Axisymmetric simulations</a></li>
<li class="toctree-l2"><a class="reference internal" href="#running-multiple-simulations-from-one-input-script">6.3. Running multiple simulations from one input script</a></li>
<li class="toctree-l2"><a class="reference internal" href="#output-from-sparta-stats-dumps-computes-fixes-variables">6.4. Output from SPARTA (stats, dumps, computes, fixes, variables)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#global-per-particle-per-grid-per-surf-data">6.4.1. Global/per-particle/per-grid/per-surf data</a></li>
<li class="toctree-l3"><a class="reference internal" href="#scalar-vector-array-data">6.4.2. Scalar/vector/array data</a></li>
<li class="toctree-l3"><a class="reference internal" href="#statistical-output">6.4.3. Statistical output</a></li>
<li class="toctree-l3"><a class="reference internal" href="#dump-file-output">6.4.4. Dump file output</a></li>
<li class="toctree-l3"><a class="reference internal" href="#fixes-that-write-output-files">6.4.5. Fixes that write output files</a></li>
<li class="toctree-l3"><a class="reference internal" href="#computes-that-process-output-quantities">6.4.6. Computes that process output quantities</a></li>
<li class="toctree-l3"><a class="reference internal" href="#computes-that-generate-values-to-output">6.4.7. Computes that generate values to output</a></li>
<li class="toctree-l3"><a class="reference internal" href="#fixes-that-generate-values-to-output">6.4.8. Fixes that generate values to output</a></li>
<li class="toctree-l3"><a class="reference internal" href="#variables-that-generate-values-to-output">6.4.9. Variables that generate values to output</a></li>
<li class="toctree-l3"><a class="reference internal" href="#summary-table-of-output-options-and-data-flow-between-commands">6.4.10. Summary table of output options and data flow between commands</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#visualizing-sparta-snapshots">6.5. Visualizing SPARTA snapshots</a></li>
<li class="toctree-l2"><a class="reference internal" href="#library-interface-to-sparta">6.6. Library interface to SPARTA</a></li>
<li class="toctree-l2"><a class="reference internal" href="#coupling-sparta-to-other-codes">6.7. Coupling SPARTA to other codes</a></li>
<li class="toctree-l2"><a class="reference internal" href="#details-of-grid-geometry-in-sparta">6.8. Details of grid geometry in SPARTA</a></li>
<li class="toctree-l2"><a class="reference internal" href="#details-of-surfaces-in-sparta">6.9. Details of surfaces in SPARTA</a></li>
<li class="toctree-l2"><a class="reference internal" href="#restarting-a-simulation">6.10. Restarting a simulation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#using-the-ambipolar-approximation">6.11. Using the ambipolar approximation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#using-multiple-vibrational-energy-levels">6.12. Using multiple vibrational energy levels</a></li>
<li class="toctree-l2"><a class="reference internal" href="#surface-elements-explicit-implicit-distributed">6.13. Surface elements: explicit, implicit, distributed</a></li>
<li class="toctree-l2"><a class="reference internal" href="#implicit-surface-ablation">6.14. Implicit surface ablation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#transparent-surface-elements">6.15. Transparent surface elements</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Section_example.html">7. Example problems</a></li>
<li class="toctree-l1"><a class="reference internal" href="Section_perf.html">8. Performance &amp; scalability</a></li>
<li class="toctree-l1"><a class="reference internal" href="Section_tools.html">9. Additional tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="Section_modify.html">10. Modifying &amp; extending SPARTA</a></li>
<li class="toctree-l1"><a class="reference internal" href="Section_python.html">11. Python interface to SPARTA</a></li>
<li class="toctree-l1"><a class="reference internal" href="Section_errors.html">12. Errors</a></li>
<li class="toctree-l1"><a class="reference internal" href="Section_history.html">13. Future and history</a></li>
<li class="toctree-l1"><a class="reference internal" href="commands.html">14. List of Commands</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">SPARTA</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>6. How-to discussions</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/Section_howto.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="how-to-discussions">
<span id="howto"></span><h1>6. How-to discussions<a class="headerlink" href="#how-to-discussions" title="Permalink to this headline">¶</a></h1>
<p>The following sections describe how to perform common tasks using
SPARTA, as well as provide some techinical details about how SPARTA
works.</p>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#d-simulations" id="id2">2d simulations</a></p></li>
<li><p><a class="reference internal" href="#axisymmetric-simulations" id="id3">Axisymmetric simulations</a></p></li>
<li><p><a class="reference internal" href="#running-multiple-simulations-from-one-input-script" id="id4">Running multiple simulations from one input script</a></p></li>
<li><p><a class="reference internal" href="#output-from-sparta-stats-dumps-computes-fixes-variables" id="id5">Output from SPARTA (stats, dumps, computes, fixes, variables)</a></p></li>
<li><p><a class="reference internal" href="#visualizing-sparta-snapshots" id="id6">Visualizing SPARTA snapshots</a></p></li>
<li><p><a class="reference internal" href="#library-interface-to-sparta" id="id7">Library interface to SPARTA</a></p></li>
<li><p><a class="reference internal" href="#coupling-sparta-to-other-codes" id="id8">Coupling SPARTA to other codes</a></p></li>
<li><p><a class="reference internal" href="#details-of-grid-geometry-in-sparta" id="id9">Details of grid geometry in SPARTA</a></p></li>
<li><p><a class="reference internal" href="#details-of-surfaces-in-sparta" id="id10">Details of surfaces in SPARTA</a></p></li>
<li><p><a class="reference internal" href="#restarting-a-simulation" id="id11">Restarting a simulation</a></p></li>
<li><p><a class="reference internal" href="#using-the-ambipolar-approximation" id="id12">Using the ambipolar approximation</a></p></li>
<li><p><a class="reference internal" href="#using-multiple-vibrational-energy-levels" id="id13">Using multiple vibrational energy levels</a></p></li>
<li><p><a class="reference internal" href="#surface-elements-explicit-implicit-distributed" id="id14">Surface elements: explicit, implicit, distributed</a></p></li>
<li><p><a class="reference internal" href="#implicit-surface-ablation" id="id15">Implicit surface ablation</a></p></li>
<li><p><a class="reference internal" href="#transparent-surface-elements" id="id16">Transparent surface elements</a></p></li>
</ul>
</div>
<p>The example input scripts included in the SPARTA distribution and
highlighted in <a class="reference internal" href="Section_example.html#examples"><span class="std std-ref">Example problems</span></a> of the manual also show how to setup
and run various kinds of simulations.</p>
<div class="section" id="d-simulations">
<h2><a class="toc-backref" href="#id2">6.1. 2d simulations</a><a class="headerlink" href="#d-simulations" title="Permalink to this headline">¶</a></h2>
<p>In SPARTA, as in other DSMC codes, a 2d simulation means that particles
move only in the xy plane, but still have all 3 xyz components of
velocity. Only the xy components of velocity are used to advect the
particles, so that they stay in the xy plane, but all 3 components are
used to compute collision parameters, temperatures, etc. Here are the
steps to take in an input script to setup a 2d model.</p>
<ul class="simple">
<li><p>Use the <a class="reference internal" href="dimension.html#command-dimension"><span class="std std-ref">dimension command</span></a> to specify a 2d simulation.</p></li>
<li><p>Make the simulation box periodic in z via the <a class="reference internal" href="boundary.html#command-boundary"><span class="std std-ref">boundary command</span></a>. This is the default.</p></li>
<li><p>Using the <a class="reference internal" href="create_box.html#command-create-box"><span class="std std-ref">create_box command</span></a>, set the z boundaries of the box to values that straddle the <code class="docutils literal notranslate"><span class="pre">z</span> <span class="pre">=</span> <span class="pre">0.0</span></code> plane. I.e. <code class="docutils literal notranslate"><span class="pre">zlo</span> <span class="pre">&lt;</span> <span class="pre">0.0</span> <span class="pre">and</span> <span class="pre">zhi</span> <span class="pre">&gt;</span> <span class="pre">0.0</span></code>. Typical values are -0.5 and 0.5, but regardless of the actual values, SPARTA computes the “volume” of 2d  grid cells as if their z-dimension length is 1.0, in whatever <a class="reference internal" href="units.html#command-units"><span class="std std-ref">units</span></a> are defined. This volume is used with the <a class="reference internal" href="global.html#command-global"><span class="std std-ref">global nrho</span></a> setting to calculate numbers of particles to create or insert. It is also used to compute collision frequencies.</p></li>
<li><p>If surfaces are defined via the <a class="reference internal" href="read_surf.html#command-read-surf"><span class="std std-ref">read_surf command</span></a>, use 2d objects defined by line segements.</p></li>
</ul>
<p>Many of the example input scripts included in the SPARTA distribution are for 2d models.</p>
</div>
<div class="section" id="axisymmetric-simulations">
<span id="howto-axisymmetric"></span><h2><a class="toc-backref" href="#id3">6.2. Axisymmetric simulations</a><a class="headerlink" href="#axisymmetric-simulations" title="Permalink to this headline">¶</a></h2>
<p>In SPARTA, an axi-symmetric model is a 2d model. An example input script is provided in the examples/axisymm directory.</p>
<p>An axi-symmetric problem can be setup using the following commands:</p>
<ul class="simple">
<li><p>Set <code class="docutils literal notranslate"><span class="pre">dimension</span> <span class="pre">=</span> <span class="pre">2</span></code> via the <a class="reference internal" href="dimension.html#command-dimension"><span class="std std-ref">dimension command</span></a>.</p></li>
<li><p>Set the y-dimension lower boundary to “a” via the <a class="reference internal" href="boundary.html#command-boundary"><span class="std std-ref">boundary command</span></a>.</p></li>
<li><p>The y-dimension upper boundary can be anything except “a” or “p” for periodic.</p></li>
<li><p>Use the <a class="reference internal" href="create_box.html#command-create-box"><span class="std std-ref">create_box command</span></a> to define a 2d simulation box with <code class="docutils literal notranslate"><span class="pre">ylo</span> <span class="pre">=</span> <span class="pre">0.0</span></code>.</p></li>
</ul>
<p>If desired, grid cell weighting can be enabled via the <a class="reference internal" href="global.html#command-global"><span class="std std-ref">global weight</span></a> command.
The <em>volume</em> or <em>radial</em> setting can be used for axi-symmetric models.</p>
<p>Grid cell weighting affects how many particles per grid cell are created
when using the <a class="reference internal" href="create_particles.html#command-create-particles"><span class="std std-ref">create_particles command</span></a> and <a class="reference internal" href="fix_emit_face.html#command-fix-emit-face"><span class="std std-ref">fix emit/face command</span></a> variants.</p>
<p>During a run, it also triggers particle cloning and destruction as
particles move from grid cell to grid cell. This can be important for
inducing every grid cell to contain roughly the same number of
particles, even if cells are of varying volume, as they often are in
axi-symmetric models. Note that the effective volume of an axi-symmetric
grid cell is the volume its 2d area sweeps out when rotated around the
y=0 axis of symmetry.</p>
</div>
<div class="section" id="running-multiple-simulations-from-one-input-script">
<span id="howto-multiple-simulations"></span><h2><a class="toc-backref" href="#id4">6.3. Running multiple simulations from one input script</a><a class="headerlink" href="#running-multiple-simulations-from-one-input-script" title="Permalink to this headline">¶</a></h2>
<p>This can be done in several ways. See the documentation for individual
commands for more details on how these examples work.</p>
<p>If “multiple simulations” means continue a previous simulation for more
timesteps, then you simply use the <a class="reference internal" href="run.html#command-run"><span class="std std-ref">run command</span></a> multiple
times. For example, this script</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">read_grid</span> <span class="n">data</span><span class="o">.</span><span class="n">grid</span>
<span class="n">create_particles</span> <span class="mi">1000000</span>
<span class="n">run</span> <span class="mi">10000</span>
<span class="n">run</span> <span class="mi">10000</span>
<span class="n">run</span> <span class="mi">10000</span>
<span class="n">run</span> <span class="mi">10000</span>
<span class="n">run</span> <span class="mi">10000</span>
</pre></div>
</div>
<p>would run 5 successive simulations of the same system for a total of 50,000 timesteps.</p>
<p>If you wish to run totally different simulations, one after the other,
the <a class="reference internal" href="clear.html#command-clear"><span class="std std-ref">clear command</span></a> command can be used in between them to re-initialize SPARTA. For example, this script</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">read_grid</span> <span class="n">data</span><span class="o">.</span><span class="n">grid</span>
<span class="n">create_particles</span> <span class="mi">1000000</span>
<span class="n">run</span> <span class="mi">10000</span>
<span class="n">clear</span>
<span class="n">read_grid</span> <span class="n">data</span><span class="o">.</span><span class="n">grid2</span>
<span class="n">create_particles</span> <span class="mi">500000</span>
<span class="n">run</span> <span class="mi">10000</span>
</pre></div>
</div>
<p>would run 2 independent simulations, one after the other.</p>
<p>For large numbers of independent simulations, you can use <a class="reference internal" href="variable.html#command-variable"><span class="std std-ref">variable command</span></a>, and <a class="reference internal" href="next.html#command-next"><span class="std std-ref">next command</span></a>, and <a class="reference internal" href="jump.html#command-jump"><span class="std std-ref">jump command</span></a> to loop over the same input script multiple times with different settings. For example, this script, named <code class="docutils literal notranslate"><span class="pre">in.flow</span></code></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>variable d index run1 run2 run3 run4 run5 run6 run7 run8
shell cd $d
read_grid data.grid
create_particles 1000000
run 10000
shell cd ..
clear
next d
jump in.flow
</pre></div>
</div>
<p>would run 8 simulations in different directories, using a data.grid file
in each directory. The same concept could be used to run the same system
at 8 different gas densities, using a density variable and storing the
output in different log and dump files, for example</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>variable a loop 8
variable rho index 1.0e18 4.0e18 1.0e19 4.0e19 1.0e20 4.0e20 1.0e21 4.0e21
log log.$a
read data.grid
global nrho ${rho}
...
compute myGrid grid all all n temp
dump 1 grid all 1000 dump.$a id c_myGrid
run 100000
clear
next rho
next a
jump in.flow
</pre></div>
</div>
<p>All of the above examples work whether you are running on 1 or multiple
processors, but assumed you are running SPARTA on a single partition of
processors. SPARTA can be run on multiple partitions via the
“-partition” command-line switch as described in <a class="reference internal" href="Section_start.html#start-command-line-options"><span class="std std-ref">Command-line options</span></a> of the manual.</p>
<p>In the last 2 examples, if SPARTA were run on 3 partitions, the same scripts could be used if the “index” and “loop” variables were replaced with <em>universe</em>-style variables, as described in the <a class="reference internal" href="variable.html#command-variable"><span class="std std-ref">variable command</span></a> command. Also, the <code class="docutils literal notranslate"><span class="pre">next</span> <span class="pre">rho</span></code> and <code class="docutils literal notranslate"><span class="pre">next</span> <span class="pre">a</span></code> commands would need to be replaced with a single <code class="docutils literal notranslate"><span class="pre">next</span> <span class="pre">a</span> <span class="pre">rho</span></code> command.  With these modifications, the 8 simulations of each script would
run on the 3 partitions one after the other until all were finished. Initially, 3 simulations would be started simultaneously, one on each partition.  When one finished, that partition would then start the 4th simulation, and so forth, until all 8 were completed.</p>
</div>
<div class="section" id="output-from-sparta-stats-dumps-computes-fixes-variables">
<span id="howto-output"></span><h2><a class="toc-backref" href="#id5">6.4. Output from SPARTA (stats, dumps, computes, fixes, variables)</a><a class="headerlink" href="#output-from-sparta-stats-dumps-computes-fixes-variables" title="Permalink to this headline">¶</a></h2>
<p>There are four basic kinds of SPARTA output:</p>
<ul class="simple">
<li><p><a class="reference internal" href="stats_style.html#command-stats-style"><span class="std std-ref">Statistical output</span></a>, which is a list of quantities printed every few timesteps to the screen and logfile.</p></li>
<li><p><a class="reference internal" href="dump.html#command-dump"><span class="std std-ref">Dump files</span></a>, which contain snapshots of particle, grid cell, or surface element quantities and are written at a specified frequency.</p></li>
<li><p>Certain fixes can output user-specified quantities directly to files: <a class="reference internal" href="fix_ave_time.html#command-fix-ave-time"><span class="std std-ref">fix ave/time</span></a> for time averaging, and <a class="reference internal" href="fix_print.html#command-fix-print"><span class="std std-ref">fix print</span></a> for single-line output of <a class="reference internal" href="variable.html#command-variable"><span class="std std-ref">variables</span></a>. Fix print can also output to the screen.</p></li>
<li><p><a class="reference internal" href="restart.html#command-restart"><span class="std std-ref">Restart files</span></a>.</p></li>
</ul>
<p>A simulation prints one set of statistical output and (optionally)
restart files. It can generate any number of dump files and fix output
files, depending on what <a class="reference internal" href="dump.html#command-dump"><span class="std std-ref">dump command</span></a> and <a class="reference internal" href="fix.html#command-fix"><span class="std std-ref">fix command</span></a> you specify.</p>
<p>As discussed below, SPARTA gives you a variety of ways to determine what quantities are computed and printed when the statistics, dump, or fix commands listed above perform output. Throughout this discussion, note that users can also add their own computes and fixes to SPARTA (see <a class="reference internal" href="Section_modify.html#modify"><span class="std std-ref">Modifying &amp; extending SPARTA</span></a>) which can generate values that can then be output with these commands.</p>
<p>The following sub-sections discuss different SPARTA commands related to
output and the kind of data they operate on and produce:</p>
<div class="contents local topic" id="id1">
<ul class="simple">
<li><p><a class="reference internal" href="#global-per-particle-per-grid-per-surf-data" id="id17">Global/per-particle/per-grid/per-surf data</a></p></li>
<li><p><a class="reference internal" href="#scalar-vector-array-data" id="id18">Scalar/vector/array data</a></p></li>
<li><p><a class="reference internal" href="#statistical-output" id="id19">Statistical output</a></p></li>
<li><p><a class="reference internal" href="#dump-file-output" id="id20">Dump file output</a></p></li>
<li><p><a class="reference internal" href="#fixes-that-write-output-files" id="id21">Fixes that write output files</a></p></li>
<li><p><a class="reference internal" href="#computes-that-process-output-quantities" id="id22">Computes that process output quantities</a></p></li>
<li><p><a class="reference internal" href="#computes-that-generate-values-to-output" id="id23">Computes that generate values to output</a></p></li>
<li><p><a class="reference internal" href="#fixes-that-generate-values-to-output" id="id24">Fixes that generate values to output</a></p></li>
<li><p><a class="reference internal" href="#variables-that-generate-values-to-output" id="id25">Variables that generate values to output</a></p></li>
<li><p><a class="reference internal" href="#summary-table-of-output-options-and-data-flow-between-commands" id="id26">Summary table of output options and data flow between commands</a></p></li>
</ul>
</div>
<div class="section" id="global-per-particle-per-grid-per-surf-data">
<span id="howto-global"></span><h3><a class="toc-backref" href="#id17">6.4.1. Global/per-particle/per-grid/per-surf data</a><a class="headerlink" href="#global-per-particle-per-grid-per-surf-data" title="Permalink to this headline">¶</a></h3>
<p>Various output-related commands work with four different styles of data:
global, per particle, per grid, or per surf. A global datum is one or
more system-wide values, e.g. the temperature of the system. A per
particle datum is one or more values per partice, e.g. the kinetic
energy of each particle. A per grid datum is one or more values per grid
cell, e.g. the temperature of the particles in the grid cell. A per surf
datum is one or more values per surface element, e.g. the count of
particles that collided with the surface element.</p>
</div>
<div class="section" id="scalar-vector-array-data">
<h3><a class="toc-backref" href="#id18">6.4.2. Scalar/vector/array data</a><a class="headerlink" href="#scalar-vector-array-data" title="Permalink to this headline">¶</a></h3>
<p>Global, per particle, per grid, and per surf datums can each come in
three kinds: a single scalar value, a vector of values, or a 2d array of
values. The doc page for a “compute” or “fix” or “variable” that
generates data will specify both the style and kind of data it produces,
e.g. a per grid vector.</p>
<p>When a quantity is accessed, as in many of the output commands discussed
below, it can be referenced via the following bracket notation, where ID
in this case is the ID of a compute. The leading <cite>c_</cite> would be replaced
by <code class="docutils literal notranslate"><span class="pre">f_</span></code> for a fix, or <code class="docutils literal notranslate"><span class="pre">v_</span></code> for a variable:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>c_ID</p></td>
<td><p>entire scalar, vector, or array</p></td>
</tr>
<tr class="row-even"><td><p>c_ID[I]</p></td>
<td><p>one element of vector, one column of array</p></td>
</tr>
<tr class="row-odd"><td><p>c_ID[I][J]</p></td>
<td><p>one element of array</p></td>
</tr>
</tbody>
</table>
<p>In other words, using one bracket reduces the dimension of the data once
(vector -&gt; scalar, array -&gt; vector). Using two brackets reduces the
dimension twice (array -&gt; scalar). Thus a command that uses scalar
values as input can typically also process elements of a vector or
array.</p>
</div>
<div class="section" id="statistical-output">
<h3><a class="toc-backref" href="#id19">6.4.3. Statistical output</a><a class="headerlink" href="#statistical-output" title="Permalink to this headline">¶</a></h3>
<p>The frequency and format of statistical output is set by the <a class="reference internal" href="stats.html#command-stats"><span class="std std-ref">stats</span></a>, <a class="reference internal" href="stats_style.html#command-stats-style"><span class="std std-ref">stats_style command</span></a>, and <a class="reference internal" href="stats_modify.html#command-stats-modify"><span class="std std-ref">stats_modify command</span></a>.  The <a class="reference internal" href="stats_style.html#command-stats-style"><span class="std std-ref">stats_style command</span></a> also specifies what values are calculated and written out. Pre-defined keywords can be specified (e.g. np, ncoll, etc).
Three additional kinds of keywords can also be specified (c_ID, f_ID, v_name), where a <a class="reference internal" href="compute.html#command-compute"><span class="std std-ref">compute command</span></a> or <a class="reference internal" href="fix.html#command-fix"><span class="std std-ref">fix command</span></a> or <a class="reference internal" href="variable.html#command-variable"><span class="std std-ref">variable command</span></a> provides the value to be output. In each case, the compute, fix, or variable must generate global values to be used as an argument of the <a class="reference internal" href="stats_style.html#command-stats-style"><span class="std std-ref">stats_style command</span></a>.</p>
</div>
<div class="section" id="dump-file-output">
<h3><a class="toc-backref" href="#id20">6.4.4. Dump file output</a><a class="headerlink" href="#dump-file-output" title="Permalink to this headline">¶</a></h3>
<p>Dump file output is specified by the <a class="reference internal" href="dump.html#command-dump"><span class="std std-ref">dump command</span></a> and <a class="reference internal" href="dump_modify.html#command-dump-modify"><span class="std std-ref">dump_modify command</span></a>. There are several pre-defined formats: dump particle, dump grid, dump surf, etc.</p>
<p>Each of these allows specification of what values are output with each particle, grid cell, or surface element. Pre-defined attributes can be specified (e.g. id, x, y, z for particles or id, vol for grid cells, etc). Three additional kinds of keywords can also be specified (c_ID, f_ID, v_name), where a <a class="reference internal" href="compute.html#command-compute"><span class="std std-ref">compute command</span></a> or <a class="reference internal" href="fix.html#command-fix"><span class="std std-ref">fix command</span></a> or <a class="reference internal" href="variable.html#command-variable"><span class="std std-ref">variable command</span></a> provides the values to be output. In each case, the compute, fix, or variable must generate per particle, per grid, or per surf values for input to the corresponding <a class="reference internal" href="dump.html#command-dump"><span class="std std-ref">dump command</span></a>.</p>
</div>
<div class="section" id="fixes-that-write-output-files">
<h3><a class="toc-backref" href="#id21">6.4.5. Fixes that write output files</a><a class="headerlink" href="#fixes-that-write-output-files" title="Permalink to this headline">¶</a></h3>
<p>Two fixes take various quantities as input and can write output files:
<a class="reference internal" href="fix_ave_time.html#command-fix-ave-time"><span class="std std-ref">fix ave/time</span></a> and <a class="reference internal" href="fix_print.html#command-fix-print"><span class="std std-ref">fix print</span></a>.</p>
<p>The <a class="reference internal" href="fix_ave_time.html#command-fix-ave-time"><span class="std std-ref">fix ave/time command</span></a> command enables direct output to a file and/or time-averaging of global scalars or vectors. The user specifies one or more quantities as input. These can be global <a class="reference internal" href="compute.html#command-compute"><span class="std std-ref">compute</span></a> values, global <a class="reference internal" href="fix.html#command-fix"><span class="std std-ref">fix</span></a> values, or <a class="reference internal" href="variable.html#command-variable"><span class="std std-ref">variables</span></a> of any style except the particle style which does not produce single values. Since a variable can refer to keywords used by the <a class="reference internal" href="stats_style.html#command-stats-style"><span class="std std-ref">stats_style command</span></a> (like particle count), a wide variety of quantities can be time averaged and/or output in this way.
If the inputs are one or more scalar values, then the fix generates a global scalar or vector of output. If the inputs are one or more vector values, then the fix generates a global vector or array of output. The time-averaged
output of this fix can also be used as input to other output commands.</p>
<p>The <a class="reference internal" href="fix_print.html#command-fix-print"><span class="std std-ref">fix print command</span></a> can generate a line of output written to the screen and log file or to a separate file, periodically during a running simulation. The line can contain one or more <a class="reference internal" href="variable.html#command-variable"><span class="std std-ref">variable</span></a> values for any style variable except the particle style. As explained above, variables themselves can contain references to global values generated by <a class="reference internal" href="stats_style.html#command-stats-style"><span class="std std-ref">stats keywords</span></a>, <a class="reference internal" href="compute.html#command-compute"><span class="std std-ref">computes</span></a>, <a class="reference internal" href="fix.html#command-fix"><span class="std std-ref">fixes</span></a>, or other <a class="reference internal" href="variable.html#command-variable"><span class="std std-ref">variables</span></a>. Thus the <a class="reference internal" href="fix_print.html#command-fix-print"><span class="std std-ref">fix print command</span></a> is a means to output a wide variety of quantities separate from normal statistical or dump file output.</p>
</div>
<div class="section" id="computes-that-process-output-quantities">
<h3><a class="toc-backref" href="#id22">6.4.6. Computes that process output quantities</a><a class="headerlink" href="#computes-that-process-output-quantities" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="compute_reduce.html#command-compute-reduce"><span class="std std-ref">compute reduce command</span></a> takes one or more per particle or per grid or per surf vector quantities as inputs and “reduces” them (sum, min, max, ave) to scalar quantities. These are produced as output values which can be used as input to other output commands.</p>
</div>
<div class="section" id="computes-that-generate-values-to-output">
<h3><a class="toc-backref" href="#id23">6.4.7. Computes that generate values to output</a><a class="headerlink" href="#computes-that-generate-values-to-output" title="Permalink to this headline">¶</a></h3>
<p>Every <a class="reference internal" href="compute.html#command-compute"><span class="std std-ref">compute</span></a> in SPARTA produces either global or per particle or per grid or per surf values. The values can be scalars or vectors or arrays of data. These values can be output using the other commands described in this section. The doc page for each compute command describes what it produces. Computes that produce per particle or per grid or per surf values have the word “particle” or “grid” or “surf” in their style name. Computes without those words produce global values.</p>
</div>
<div class="section" id="fixes-that-generate-values-to-output">
<h3><a class="toc-backref" href="#id24">6.4.8. Fixes that generate values to output</a><a class="headerlink" href="#fixes-that-generate-values-to-output" title="Permalink to this headline">¶</a></h3>
<p>Some <a class="reference internal" href="fix.html#command-fix"><span class="std std-ref">fixes</span></a> in SPARTA produces either global or per particle or per grid or per surf values which can be accessed by other commands. The values can be scalars or vectors or arrays of data. These values can be output using the other commands described in this section.  The doc page for each fix command tells whether it produces any output quantities and describes them.</p>
<p>Two fixes of particular interest for output are the <a class="reference internal" href="fix_ave_grid.html#command-fix-ave-grid"><span class="std std-ref">fix ave/grid command</span></a> and <a class="reference internal" href="fix_ave_surf.html#command-fix-ave-surf"><span class="std std-ref">fix ave/surf command</span></a>.</p>
<p>The <a class="reference internal" href="fix_ave_grid.html#command-fix-ave-grid"><span class="std std-ref">fix ave/grid command</span></a> command enables time-averaging of per grid vectors. The user specifies one or more quantities as input.  These can be per grid vectors or arrays from <a class="reference internal" href="compute.html#command-compute"><span class="std std-ref">compute command</span></a> or <a class="reference internal" href="fix.html#command-fix"><span class="std std-ref">fix command</span></a>. If the input is a single vector, then the fix generates a per grid vector. If the input is multiple vectors or array, the fix generates a per grid array. The time-averaged output of this fix can also be used as input to other output commands.</p>
<p>The <a class="reference internal" href="fix_ave_surf.html#command-fix-ave-surf"><span class="std std-ref">fix ave/surf command</span></a> enables time-averaging of per surf vectors. The user specifies one or more quantities as input.  These can be per surf vectors or ararys from <a class="reference internal" href="compute.html#command-compute"><span class="std std-ref">compute command</span></a> or <a class="reference internal" href="fix.html#command-fix"><span class="std std-ref">fix command</span></a>. If the input is a single vector, then the fix generates a per surf vector. If the input is multiple vectors or array, the fix generates a per surf array. The time-averaged output of this fix can also be used as input to other output commands.</p>
</div>
<div class="section" id="variables-that-generate-values-to-output">
<h3><a class="toc-backref" href="#id25">6.4.9. Variables that generate values to output</a><a class="headerlink" href="#variables-that-generate-values-to-output" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="variable.html#command-variable"><span class="std std-ref">Variables</span></a> defined in an input script generate either
a global scalar value or a per particle vector (only particle-style
variables) when it is accessed. The formulas used to define equal- and
particle-style variables can contain references to the
<a class="reference internal" href="stats_style.html#command-stats-style"><span class="std std-ref">stats_style</span></a> keywords and to global and per
particle data generated by computes, fixes, and other variables. The
values generated by variables can be output using the other commands
described in this section.</p>
</div>
<div class="section" id="summary-table-of-output-options-and-data-flow-between-commands">
<h3><a class="toc-backref" href="#id26">6.4.10. Summary table of output options and data flow between commands</a><a class="headerlink" href="#summary-table-of-output-options-and-data-flow-between-commands" title="Permalink to this headline">¶</a></h3>
<p>This table summarizes the various commands that can be used for generating output from SPARTA. Each command produces output data of some kind and/or writes data to a file. Most of the commands can take data from other commands as input. Thus you can link many of these commands together in pipeline form, where data produced by one command is used as input to another command and eventually written to the screen or to a file. Note that to hook two commands together the output and input data types must match, e.g. global/per atom/local data and scalar/vector/array data.</p>
<p>Also note that, as described above, when a command takes a scalar as input, that could be an element of a vector or array. Likewise a vector input could be a column of an array.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Command</p></td>
<td><p>Input</p></td>
<td><p>Output</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="stats_style.html#command-stats-style"><span class="std std-ref">stats_style</span></a></p></td>
<td><p>global scalars</p></td>
<td><p>screen, log file</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="dump.html#command-dump"><span class="std std-ref">dump particle</span></a></p></td>
<td><p>per particle vectors</p></td>
<td><p>dump file</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="dump.html#command-dump"><span class="std std-ref">dump grid</span></a></p></td>
<td><p>per grid vectors</p></td>
<td><p>dump file</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="dump.html#command-dump"><span class="std std-ref">dump surf</span></a></p></td>
<td><p>per surf vectors</p></td>
<td><p>dump file</p></td>
</tr>
<tr class="row-even"><td><p><cite>fix print &lt;command-fix-print&gt;</cite></p></td>
<td><p>global scalar from variable</p></td>
<td><p>screen, file</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="print.html#command-print"><span class="std std-ref">print</span></a></p></td>
<td><p>global scalar from variable</p></td>
<td><p>screen</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="compute.html#command-compute"><span class="std std-ref">computes</span></a></p></td>
<td><p>N/A</p></td>
<td><p>global or per particle/grid/surf scalar/vector/array</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="fix.html#command-fix"><span class="std std-ref">fixes</span></a></p></td>
<td><p>N/A</p></td>
<td><p>global or per particle/grid/surf scalar/vector/array</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="variable.html#command-variable"><span class="std std-ref">variables</span></a></p></td>
<td><p>global scalars, per particle vectors</p></td>
<td><p>global scalar, per particle vector</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="compute_reduce.html#command-compute-reduce"><span class="std std-ref">compute reduce</span></a></p></td>
<td><p>per particle/grid/surf vectors</p></td>
<td><p>global scalar/vector</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="fix_ave_time.html#command-fix-ave-time"><span class="std std-ref">fix ave/time</span></a></p></td>
<td><p>global scalars/vectors</p></td>
<td><p>global scalar/vector/array, file</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="fix_ave_grid.html#command-fix-ave-grid"><span class="std std-ref">fix ave/grid</span></a></p></td>
<td><p>per grid vectors/arrays</p></td>
<td><p>per grid vector/array</p></td>
</tr>
<tr class="row-even"><td><p><cite>fix ave/surf &lt;command-fix-ave-surf&gt;</cite></p></td>
<td><p>per surf vectors/arrays</p></td>
<td><p>per surf vector/array</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="visualizing-sparta-snapshots">
<h2><a class="toc-backref" href="#id6">6.5. Visualizing SPARTA snapshots</a><a class="headerlink" href="#visualizing-sparta-snapshots" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="dump_image.html#command-dump-image"><span class="std std-ref">dump image command</span></a> can be used to do
on-the-fly visualization as a simulation proceeds. It works by creating
a series of JPG or PNG or PPM files on specified timesteps, as well as
movies. The images can include particles, grid cell quantities, and/or
surface element quantities. This is not a substitute for using an
interactive visualization package in post-processing mode, but
on-the-fly visualization can be useful for debugging or making a
high-quality image of a particular snapshot of the simulation.</p>
<p>The <a class="reference internal" href="dump.html#command-dump"><span class="std std-ref">dump command</span></a> can be used to create snapshots of particle, grid cell, or surface element data as a simulation runs. These can be post-processed and read in to other visualization packages.</p>
<p>A Python-based toolkit distributed by our group can read SPARTA particle dump files with columns of user-specified particle information, and convert them to various formats or pipe them into visualization software directly.
See the <a class="reference external" href="http://www.sandia.gov/~sjplimp/pizza.html">Pizza.py WWW site</a> for details.  Specifically, Pizza.py can convert SPARTA particle dump files into PDB, XYZ, <a class="reference external" href="http://www.ensight.com">Ensight</a>, and VTK formats. Pizza.py can pipe SPARTA dump files directly into the Raster3d and RasMol visualization programs. Pizza.py has tools that do interactive 3d OpenGL visualization and one that creates SVG images of dump file snapshots.</p>
<p>Additional Pizza.py tools may be added that allow visualization of surface and grid cell information as output by SPARTA.</p>
</div>
<div class="section" id="library-interface-to-sparta">
<span id="howto-library"></span><h2><a class="toc-backref" href="#id7">6.6. Library interface to SPARTA</a><a class="headerlink" href="#library-interface-to-sparta" title="Permalink to this headline">¶</a></h2>
<p>As described in <a class="reference internal" href="Section_start.html#build-library"><span class="std std-ref">Building SPARTA as a library</span></a>, SPARTA can be built as a library, so that it can be called by another code, used in a <a class="reference internal" href="#howto-other-code"><span class="std std-ref">coupled manner</span></a> with other codes, or driven through a <a class="reference internal" href="Section_python.html#python"><span class="std std-ref">Python interface</span></a>.</p>
<p>All of these methodologies use a C-style interface to SPARTA that is provided in the files src/library.cpp and src/library.h. The functions therein have a C-style argument list, but contain C++ code you could write yourself in a C++ application that was invoking SPARTA directly.  The C++ code in the functions illustrates how to invoke internal SPARTA operations. Note that SPARTA classes are defined within a SPARTA namespace (SPARTA_NS) if you use them from another C++ application.</p>
<p>Library.cpp contains these 4 functions:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">sparta_open</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="p">,</span> <span class="n">MPI_Comm</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">sparta_close</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">sparta_file</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">char</span> <span class="o">*</span><span class="nf">sparta_command</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">sparta_open()</span></code> function is used to initialize SPARTA, passing in a list of strings as if they were <a class="reference internal" href="Section_start.html#start-command-line-options"><span class="std std-ref">Command-line options</span></a> when SPARTA is run in stand-alone mode from the command line, and a MPI communicator for SPARTA to run under. It returns a ptr to the SPARTA object that is created, and which is used in subsequent library calls. The <code class="docutils literal notranslate"><span class="pre">sparta_open()</span></code> function can be called multiple times, to create multiple instances of SPARTA.</p>
<p>SPARTA will run on the set of processors in the communicator. This means the calling code can run SPARTA on all or a subset of processors. For example, a wrapper script might decide to alternate between SPARTA and another code, allowing them both to run on all the processors. Or it might allocate half the processors to SPARTA and half to the other code and run both codes simultaneously before syncing them up periodically.  Or it might instantiate multiple instances of SPARTA to perform different calculations.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">sparta_close()</span></code> function is used to shut down an instance of SPARTA and free all its memory.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">sparta_file()</span></code> and <code class="docutils literal notranslate"><span class="pre">sparta_command()</span></code> functions are used to pass a file or string to SPARTA as if it were an input script or single command in an input script. Thus the calling code can read or generate a series of SPARTA commands one line at a time and pass it thru the library interface to setup a problem and then run it, interleaving the <code class="docutils literal notranslate"><span class="pre">sparta_command()</span></code> calls with other calls to extract information from SPARTA, perform its own operations, or call another code’s library.</p>
<p>Other useful functions are also included in library.cpp. For example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="o">*</span><span class="nf">sparta_extract_global</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">sparta_extract_compute</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">sparta_extract_variable</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
</pre></div>
</div>
<p>This can extract various global quantities from SPARTA as well as values calculated by a compute or variable. See the library.cpp file and its associated header file library.h for details.</p>
<p>Other functions may be added to the library interface as needed to allow reading from or writing to internal SPARTA data structures.</p>
<p>The key idea of the library interface is that you can write any functions you wish to define how your code talks to SPARTA and add them to src/library.cpp and src/library.h, as well as to the <a class="reference internal" href="Section_python.html#python"><span class="std std-ref">Python interface</span></a>. The routines you add can in principle access or change any SPARTA data you wish. The examples/COUPLE and python directories have example C++ and C and Python codes which show how a driver code can link to SPARTA as a library, run SPARTA on a subset of processors, grab data from SPARTA, change it, and put it back into SPARTA.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>The examples/COUPLE dir has not been added to the distribution yet.</p>
</div>
</div>
<div class="section" id="coupling-sparta-to-other-codes">
<span id="howto-other-code"></span><h2><a class="toc-backref" href="#id8">6.7. Coupling SPARTA to other codes</a><a class="headerlink" href="#coupling-sparta-to-other-codes" title="Permalink to this headline">¶</a></h2>
<p>SPARTA is designed to allow it to be coupled to other codes. For example, a continuum finite element (FE) simulation might use SPARTA grid cell quantities as boundary conditions on FE nodal points, compute a FE solution, and return continuum flow conditions as boundary conditions for SPARTA to use.</p>
<p>SPARTA can be coupled to other codes in at least 3 ways. Each has advantages and disadvantages, which you’ll have to think about in the context of your application.</p>
<ol class="arabic">
<li><p>Define a new <a class="reference internal" href="fix.html#command-fix"><span class="std std-ref">fix command</span></a> that calls the other code.  In this scenario, SPARTA is the driver code. During its timestepping, the fix is invoked, and can make library calls to the other code, which has been linked to SPARTA as a library. See <a class="reference internal" href="Section_modify.html#modify"><span class="std std-ref">Modifying &amp; extending SPARTA</span></a> of the documentation for info on how to add a new fix to SPARTA.</p></li>
<li><p>Define a new SPARTA command that calls the other code. This is conceptually similar to method (1), but in this case SPARTA and the other code are on a more equal footing. Note that now the other code is not called during the timestepping of a SPARTA run, but between runs.  The SPARTA input script can be used to alternate SPARTA runs with calls to the other code, invoked via the new command. The <a class="reference internal" href="run.html#command-run"><span class="std std-ref">run command</span></a> facilitates this with its <em>every</em> option, which makes it easy to run a few steps, invoke the command, run a few steps, invoke the command, etc.</p>
<p>In this scenario, the other code can be called as a library, as in (1), or it could be a stand-alone code, invoked by a system() call made by the command (assuming your parallel machine allows one or more processors to start up another program). In the latter case the stand-alone code could communicate with SPARTA thru files that the command writes and reads.</p>
<p>See <a class="reference internal" href="Section_modify.html#modify"><span class="std std-ref">Modifying &amp; extending SPARTA</span></a> of the documentation for how to add a new command to SPARTA.</p>
</li>
<li><p>Use SPARTA as a library called by another code. In this case the other code is the driver and calls SPARTA as needed. Or a wrapper code could link and call both SPARTA and another code as libraries. Again, the <a class="reference internal" href="run.html#command-run"><span class="std std-ref">run command</span></a> has options that allow it to be invoked with minimal overhead (no setup or clean-up) if you wish to do multiple short runs, driven by another program.</p>
<p>Examples of driver codes that call SPARTA as a library are included in the examples/COUPLE directory of the SPARTA distribution; see examples/COUPLE/README for more details.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>The examples/COUPLE dir has not been added to the distribution yet.</p>
</div>
</li>
</ol>
<p><a class="reference internal" href="Section_start.html#start-optional-packages"><span class="std std-ref">Section 2.3</span></a> of the manual describes how to build SPARTA as a library. Once this is done, you can interface with SPARTA either via C++, C, Fortran, or Python (or any other language that supports a vanilla C-like interface). For example, from C++ you could create one (or more) “instances” of SPARTA, pass it an input script to process, or execute individual commands, all by invoking the correct class methods in SPARTA. From C or Fortran you can make function calls to do the same things. See <a class="reference internal" href="Section_python.html#python"><span class="std std-ref">Section_9</span></a> of the manual for a description of the Python wrapper provided with SPARTA that operates through the SPARTA library interface.</p>
<p>The files src/library.cpp and library.h contain the C-style interface to
SPARTA. See <a class="reference internal" href="#howto-library"><span class="std std-ref">Section 6.6</span></a> of the manual for a description
of the interface and how to extend it for your needs.</p>
<p>Note that the <code class="docutils literal notranslate"><span class="pre">sparta_open()</span></code> function that creates an instance of SPARTA takes an MPI communicator as an argument. This means that instance of SPARTA will run on the set of processors in the communicator. Thus the calling code can run SPARTA on all or a subset of processors. For example, a wrapper script might decide to alternate between SPARTA and another code, allowing them both to run on all the processors. Or it might allocate half the processors to SPARTA and half to the other code and run both codes simultaneously before syncing them up periodically.  Or it might instantiate multiple instances of SPARTA to perform different calculations.</p>
</div>
<div class="section" id="details-of-grid-geometry-in-sparta">
<span id="howto-grids"></span><h2><a class="toc-backref" href="#id9">6.8. Details of grid geometry in SPARTA</a><a class="headerlink" href="#details-of-grid-geometry-in-sparta" title="Permalink to this headline">¶</a></h2>
<p>SPARTA overlays a grid over the simulation domain which is used to track particles and to co-locate particles in the same grid cell for performing collision and chemistry operations. Surface elements are also assigned to grid cells they intersect with, so that particle/surface collisions can be efficiently computed.</p>
<p>SPARTA uses a Cartesian hierarchical grid. Cartesian means that the faces of a grid cell, at any level of the hierarchy, are aligned with the Cartesian xyz axes. I.e. each grid cell is an axis-aligned pallelpiped or rectangular box. The hierarchy of grid cells is defined in the following manner. The entire simulation box is a single “root” grid cell at level 0 of the hierarchy. It is sub-divided into a regular Nx by Ny by Nz grid of cells, all at level 1 of the hierarchy. “Regular” means all the Nx*Ny*Nz sub-divided cells within a parent cell are the same size. Each Nx,Ny,Nz value &gt;= 1 (although if Nx = Ny = Nz = 1 then obviously there is no sub-division). Any of the cells at level 1 can be further sub-divided in the same manner to create cells at level 2, and recursively for levels 3, 4,
etc. The Nx,Ny,Nz values for sub-dividing an individual parent cell can be uniquely chosen. All level 2 cells do not need to be sub-divided using the same Nx,Ny,Nz values. Grids for 2d and 3d simulations (see the <a class="reference internal" href="dimension.html#command-dimension"><span class="std std-ref">dimension</span></a>) follow the same rules, except that <code class="docutils literal notranslate"><span class="pre">Nz</span> <span class="pre">=</span> <span class="pre">1</span></code> is required at every level of sub-division for 2d grids.</p>
<p>Note that this manner of defining a hierarchy allows for flexible grid cell refinement in any region of the simulation domain. E.g. around a surface, or in a high-density region of the gas flow. Also note that a 3d oct-tree (quad-tree in 2d) is a special case of the SPARTA hierarchical grid, where Nx = Ny = Nz = 2 is always used to sub-divide a grid cell.</p>
<p>An example 2d hierarchical grid is shown in the diagram, for a circular surface object (in red) with the grid refined on the upwind side of the object (flow from left to right). The first level coarse grid is 18x10.  2nd level grid cells are defined in a subset of those cells with a 3x3 sub-division. A subset of the 2nd level cells contain 3rd level grid cells via a further 3x3 sub-division.</p>
<p><img alt="image0" src="_images/refine_grid.jpg" /></p>
<p>In the rest of the SPARTA manual, the following terminology is used to
refer to the cells of the hierarchical grid. The flow region is the
portion of the simulation domain that is “outside” any surface objects
and is typically filled with particles.</p>
<ul class="simple">
<li><p>root cell = the simulation box itself</p></li>
<li><p>parent cell = a grid cell at any level that is sub-divided further</p></li>
<li><p>child cell = a grid cell that is not sub-divided further</p></li>
<li><p>unsplit cell = a child cell not intersected by any surface elements</p></li>
<li><p>cut cell = a child cell intersected by one or more surface elements,
one resulting flow region</p></li>
<li><p>split cell = a child cell intersected by two or more surface
elemments, two or more resulting disjoint flow regions</p></li>
<li><p>sub cell = one disjoint flow region portion of a split cell</p></li>
</ul>
<p>The list of parent cells in a simulation is stored by every processor and is read in by the <a class="reference internal" href="read_grid.html#command-read-grid"><span class="std std-ref">read_grid command</span></a>, or defined by the <a class="reference internal" href="create_grid.html#command-create-grid"><span class="std std-ref">create_grid command</span></a>. Child cells are inferred by the same 2 commands and the union of all child cells is the entire simulation domain. Child cells are distributed across processors, so that each child cell is owned by exactly one processor, as discussed below.</p>
<p>When surface objects are defined via the <a class="reference internal" href="read_surf.html#command-read-surf"><span class="std std-ref">read_surf command</span></a>, they intersect child cells. In this contex “intersection” by a surface element means a geometric overlap between the area of the surface element and the volume of the grid cell (or length of element and area of grid cell in 2d). Thus an intersection includes a surface triangle that only touches a grid cell on its face, edge, or at its corner point. When intersected by one or more surface elements, a child cell becomes one of 3 flavors: unsplit, cut, or split. A child cell not intersected by any surface elements is an unsplit cell. It can be entirely in the flow region or entirely inside a surface object. If a child cell is intersected so that it is partitioned into two contiguous volumes, one in the flow region, the other
inside a surface object, then it is a cut cell. This is the usual case. Note that either the flow volume or inside volume can be of size zero, if the surface only “touches” the grid cell, i.e. the intersection is only on a face, edge, or corner point of the grid cell. The left side of the diagram below is an example, where red represents the flow region. Sometimes a child cell can be partitioned by surface elements so that more than one contiguous flow region is created. Then it is a split cell. Additionally, each of the two or more contiguous flow regions is a sub cell of the split cell.  The right side of the diagram shows a split cell with 3 sub cells.</p>
<p><img alt="image1" src="_images/split.jpg" /></p>
<p>The union of (1) unsplit cells that are in the flow region (not entirely interior to a surface object) and (2) flow region portions of cut cells and (3) sub cells is the entire flow region of the simulation domain.  These are the only kinds of child cells that store particles. Split cells and unsplit cells interior to surface objects have no particles.</p>
<p>Every parent and child cell is assigned an ID by SPARTA. These IDs can be output in integer or string form by the <a class="reference internal" href="dump.html#command-dump"><span class="std std-ref">dump command</span></a>, using its <em>id</em> and <em>idstr</em> attributes. The integer form can also be output by the <cite>compute property/grid &lt;command-compute-property-grid&gt;</cite>.</p>
<p>Here is how the grid cell ID is computed and stored by SPARTA. Say the 1st level grid is a 10x10x20 sub-division (2000 cells) of the root cell.  The 1st level cells are numbered from 1 to 2000 with the x-dimension varying fastest, then y, and finally the z-dimension slowest. Now say the 374th (out of 2000, 14 in x, 19 in y, 1 in z) 1st-level cell has a 2x2x2 sub-division (8 cells), and consider the 4th 2nd-level cell (2 in x, 2 in y, 1 in z) within the 374th cell. It could be a parent cell if it is further sub-divided, or a child cell if not. In either case its ID is the same. The rightmost 11 bits of the integer ID are encoded with
374.
This is because it requires 11 bits to represent 2000 cells (1 to 2000) at level 1. The next 4 bits are used to encode 1 to 8, specifically 4 in the case of this cell. Thus the cell ID in integer format is 4*2048 + 374 = 8566. In string format it will be printed as 4-374, with dashes separating the levels.</p>
<p>Note that a child cell has the same ID whether it is unsplit, cut, or split. Currently, sub cells of a split cell also have the same ID, though that may change in the future.</p>
<p>The number of hierarchical levels a SPARTA grid can contain is limited to whether all cell IDs can be encoded in an integer. By default cell IDs are stored in 32-bit integers. 64-bit integers can be used if SPARTA is compiled with the -DSPARTA_BIGBIG option, as explained in <a class="reference internal" href="Section_start.html#start-steps-build"><span class="std std-ref">Steps to build a SPARTA executable:</span></a>.</p>
<p>For 32-bit cell IDs if every level uses a 2x2x2 sub-division which requires 4 bits (to store values from 1 to 8), then a grid can have 7 levels. For 64-bit cell IDs, 15 levels could be defined.</p>
<p>The <a class="reference internal" href="create_grid.html#command-create-grid"><span class="std std-ref">create_grid command</span></a>, and <a class="reference internal" href="balance_grid.html#command-balance-grid"><span class="std std-ref">balance_grid command</span></a>, and <a class="reference internal" href="fix_balance.html#command-fix-balance"><span class="std std-ref">fix balance command - fix balance/kk command</span></a> determine the assignment of child cells to processors. If a child cell is assigned to a processor, that processor owns the cell whether it is an unsplit, cut, or split cell. It also owns any sub cells that are part of a split cell.</p>
<p>Depending on how they the commands are used, the child cells assigned to each processor will either be “clumped” or “dispersed”.</p>
<p>Clumped means each processor’s cells will be geometrically compact.  Dispersed means the processor’s cells will be geometrically dispersed across the simulation domain and so they cannot be enclosed in a small bounding box.</p>
<p>An example of a clumped assignment is shown in this zoom-in of a 2d hierarchical grid with 5 levels, refined around a tilted ellipsoidal surface object (outlined in pink). One processor owns the grid cells colored orange. A compact bounding rectangle can be drawn around the orange cells which will contain only a few grid cells owned by other processors. By contrast a dispersed assignment could scatter orange grid cells throughout the entire simulation domain.</p>
<p><img alt="image2" src="_images/partition_zoom.jpg" /></p>
<p>It is important to understand the difference between the two kinds of assignments and the effects they can have on performance of a simulation. For example the create_grid and read_grid commands may produce dispersed assignments, depending on the options used, which can be converted to a clumped assignment by the balance_grid command.</p>
<p>Simulations typically run faster with clumped grid cell assignments.  This is because the cost of communicating particles is reduced if particles that move to a neighboring grid cell often stay on-processor.  Similarly, some stages of simulation setup may run faster with a clumped assignment. Examples are the finding of nearby ghost grid cells and the computation of surface element intersections with grid cells. The latter operation is invoked when the <a class="reference internal" href="read_surf.html#command-read-surf"><span class="std std-ref">read_surf command</span></a> is used.</p>
<p>If the spatial distribution of particles is highly irregular and/or dynamically changing, or if the computational work per grid cell is otherwise highly imbalanced, a clumped assignment of grid cells to processors may not lead to optimal balancing. In these scenarios a dispersed assignment of grid cells to processsors may run faster even with the overhead of increased particle communication. This is because randomly assigning grid cells to processors can balance the computational load in a statistical sense.</p>
</div>
<div class="section" id="details-of-surfaces-in-sparta">
<span id="howto-surfaces"></span><h2><a class="toc-backref" href="#id10">6.9. Details of surfaces in SPARTA</a><a class="headerlink" href="#details-of-surfaces-in-sparta" title="Permalink to this headline">¶</a></h2>
<p>A SPARTA simulation can define one or more surface objects, each of which are read in via the <a class="reference internal" href="read_surf.html#command-read-surf"><span class="std std-ref">read_surf</span></a>. For 2d simulations a surface object is a collection of connected line segments.  For 3d simulations it is a collection of connected triangles. The outward normal of lines or triangles, as defined in the surface file, points into the flow region of the simulation box which is typically filled with particles. Depending on the orientation, surface objects can thus be obstacles that particles flow around, or they can represent the outer boundary of an irregular shaped region which particles are inside of.</p>
<p>See the <a class="reference internal" href="read_surf.html#command-read-surf"><span class="std std-ref">read_surf command</span></a> doc page for a discussion of these topics:</p>
<ul class="simple">
<li><p>Requirement that a surface object be “watertight”, so that particles do not enter inside the surface or escape it if used as an outer boundary.</p></li>
<li><p>Surface objects (one per file) that contain more than one physical object, e.g. two or more spheres in a single file.</p></li>
<li><p>Use of geometric transformations (translation, rotation, scaling, inversion) to convert the surface object in a file into different forms for use in different simulations.</p></li>
<li><p>Clipping a surface object to the simulation box to effectively use a portion of the object in a simulation, e.g. a half sphere instead of a full sphere.</p></li>
<li><p>The kinds of surface objects that are illegal, including infinitely thin objects, ones with duplicate points, or multiple surface or physical objects that touch or overlap.</p></li>
</ul>
<p>The <a class="reference internal" href="read_surf.html#command-read-surf"><span class="std std-ref">read_surf command</span></a> assigns an ID to the surface object in a file. This can be used to reference the surface elements in the object in other commands. For example, every surface object must have a collision model assigned to it so that particle bounces off the surface can be computed. This is done via the <a class="reference internal" href="surf_modify.html#command-surf-modify"><span class="std std-ref">surf_modify command</span></a> and <a class="reference internal" href="surf_collide.html#command-surf-collide"><span class="std std-ref">surf_collide command</span></a>.</p>
<p>As described in the previous Section <a class="reference internal" href="#howto-grids"><span class="std std-ref">Details of grid geometry in SPARTA</span></a>, SPARTA overlays a grid over the simulation domain to track particles. Surface elements are also assigned to grid cells they intersect with, so that particle/surface collisions can be efficiently computed. Typically a grid cell size larger than the surface elements that intersect it may not desirable since it means flow around the surface object will not be well resolved. The size of the smallest surface element in the system is printed when the surface file is read. Note that if the surface object is clipped to the simulation box, small lines or triangles can result near the box boundary due to the clipping operation.</p>
<p>The maximum number of surface elements that can intersect a single child grid cell is set by the <a class="reference internal" href="global.html#command-global"><span class="std std-ref">global surfmax</span></a> command. The default limit is 100. The actual maximum number in any grid cell is also printed when the surface file is read. Values this large or larger may cause particle moves to become expensive, since each time a particle moves within that grid cell, possible collisions with all its overlapping surface elements must be computed.</p>
</div>
<div class="section" id="restarting-a-simulation">
<span id="howto-restarting"></span><h2><a class="toc-backref" href="#id11">6.10. Restarting a simulation</a><a class="headerlink" href="#restarting-a-simulation" title="Permalink to this headline">¶</a></h2>
<p>There are two ways to continue a long SPARTA simulation. Multiple <a class="reference internal" href="run.html#command-run"><span class="std std-ref">run</span></a> commands can be used in the same input script. Each run will continue from where the previous run left off. Or binary restart files can be saved to disk using the <a class="reference internal" href="restart.html#command-restart"><span class="std std-ref">restart command</span></a>. At a later time, these binary files can be read via a <a class="reference internal" href="read_restart.html#command-read-restart"><span class="std std-ref">read_restart command</span></a> in a new script.</p>
<p>Here is an example of a script that reads a binary restart file and then issues a new run command to continue where the previous run left off. It illustrates what settings must be made in the new script. Details are discussed in the documentation for the <a class="reference internal" href="read_restart.html#command-read-restart"><span class="std std-ref">read_restart command</span></a> and <a class="reference internal" href="write_restart.html#command-write-restart"><span class="std std-ref">write_restart command</span></a>.</p>
<p>Look at the <em>in.collide</em> input script provided in the <em>bench</em> directory of the SPARTA distribution to see the original script that this script is based on. If that script had the line</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">restart</span>            <span class="mi">50</span> <span class="n">tmp</span><span class="o">.</span><span class="n">restart</span>
</pre></div>
</div>
<p>added to it, it would produce 2 binary restart files (tmp.restart.50 and tmp.restart.100) as it ran for 130 steps, one at step 50, and one at step 100.</p>
<p>This script could be used to read the first restart file and re-run the last 80 timesteps:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">read_restart</span>   <span class="n">tmp</span><span class="o">.</span><span class="n">restart</span><span class="o">.</span><span class="mi">50</span>

<span class="n">seed</span>           <span class="mi">12345</span>
<span class="n">collide</span>        <span class="n">vss</span> <span class="n">air</span> <span class="n">ar</span><span class="o">.</span><span class="n">vss</span>

<span class="n">stats</span>          <span class="mi">10</span>
<span class="n">compute</span>        <span class="n">temp</span> <span class="n">temp</span>
<span class="n">stats_style</span>    <span class="n">step</span> <span class="n">cpu</span> <span class="n">np</span> <span class="n">nattempt</span> <span class="n">ncoll</span> <span class="n">c_temp</span>

<span class="n">timestep</span>        <span class="mf">7.00E-9</span>
<span class="n">run</span>             <span class="mi">80</span>
</pre></div>
</div>
<p>Note that the following commands do not need to be repeated because their settings are included in the restart file: <em>dimension, global, boundary, create_box, create_grid, species, mixture</em>. However these commands do need to be used, since their settings are not in the restart file: <em>seed, collide, compute, fix, stats_style, timestep</em>. The <a class="reference internal" href="read_restart.html#command-read-restart"><span class="std std-ref">read_restart</span></a> doc page gives details.</p>
<p>If you actually use this script to perform a restarted run, you will notice that the statistics output does not match exactly. On step 50, the collision counts are 0 in the restarted run, because the line is printed before the restarted simulation begins. The collision counts in subsequent steps are similar but not identical. This is because new random numbers are used for collisions in the restarted run. This affects all the randomized operations in a simulation, so in general you should only expect a restarted run to be statistically similar to the original run.</p>
</div>
<div class="section" id="using-the-ambipolar-approximation">
<span id="howto-ambipolar"></span><h2><a class="toc-backref" href="#id12">6.11. Using the ambipolar approximation</a><a class="headerlink" href="#using-the-ambipolar-approximation" title="Permalink to this headline">¶</a></h2>
<p>The ambipolar approximation is a computationally efficient way to model low-density plasmas which contain positively-charged ions and negatively-charged electrons. In this model, electrons are not free particles which move independently. This would require a simulation with a very small timestep due to electon’s small mass and high speed (1000x that of an ion or neutral particle).</p>
<p>Instead each ambipolar electron is assumed to stay “close” to its parent ion, so that the plasma gas appears macroscopically neutral. Each pair of particles thus moves together through the simulation domain, as if they were a single particle, which is how they are stored within SPARTA.  This means a normal timestep can be used.</p>
<p>There are two stages during a timestep when the coupled particles are broken apart and treated as an independent ion and electron.</p>
<p>The first is during gas-phase collisions and chemistry. The ionized ambipolar particles in a grid cell are each split into two particles (ion and electron) and each can participate in two-body collisions with any other particle in the cell. Electron/electron collisions are actually not performed, but are tallied in the overall collision count.  If gas-phase chemistry is turned on, reactions involving ions and electrons can be specified, which include dissociation, ionization, exchange, and recombination reactions. At the end of the collision/chemsitry operations for the grid cell, there is still a one-to-one pairing between ambipolar ions and electrons. Each pair is recombined into a single particle.</p>
<p>The second is during collisions with surface (or the boundaries of the simulation box) if a surface reaction model is defined for the surface element or boundary. Just as with gas-phase chemistry, surface reactions involving ambipolar species can be defined. For example, an ambipolar ion/electron pair can re-combine into a neutral species during the collision.</p>
<p>Here are the SPARTA commands you can use to run a simulation using the ambipolar approximation. See the input scripts in examples/ambi for an example.</p>
<p>Note that you will likely need to use two (or more mixtures) as
arguments to various commands, one which includes the ambipolar electron
species, and one which does not. Example <a class="reference internal" href="mixture.html#command-mixture"><span class="std std-ref">mixture command</span></a> for doing this are shown below.</p>
<p>Use the <a class="reference internal" href="fix_ambipolar.html#command-fix-ambipolar"><span class="std std-ref">fix ambipolar command</span></a> to specify which species is the ambipolar electron and what (multiple) species are ambipolar ions. This is required for all the other options listed here to work. The fix defines two custom per-particles attributes, an integer vector called “ionambi” which stores a 1 for a particle if it is an ambipolar ion, and a 0 otherwise. And a floating-point array called “velambi” which stores a 3-vector with the velocity of the associated electron for each ambipolar ion or zeroes otherwise. Note that no particles should ever exist in the simulation with a species matching ambipolar electrons. Such particles are only generated (and destroyed) internally, as described above.</p>
<p>Use the <a class="reference internal" href="collide_modify.html#command-collide-modify"><span class="std std-ref">collide_modify ambipolar yes</span></a> command if you want to perform gas-phase collisions using the ambipolar model.  This is not required. If you do this, DO use a mixture which includes the ambipolar electron species, so that electrons will participate in the collisions and reactions (if defined). You probably also want to specify a mixture for the collide command which has two or more groups.  One group is for the ambipolar electron species, the other for ambipolar ions. Additional groups could exist for other species (e.g. neutrals), or those species could be part of the ion group. Putting the ambipolar electron species in its own group should improve the efficiency of the code due to the large disparity in electron versus ion/neutral velocities.</p>
<p>If you want to perform gas-phase chemistry for reactions involving ambipolar ions and electrons, use the <a class="reference internal" href="react.html#command-react"><span class="std std-ref">react command</span></a> with an input file of reactions that include the ambipolar electron and ion species defined by the fix ambipolar commmand. See the <a class="reference internal" href="react.html#command-react"><span class="std std-ref">react command</span></a> doc page for info the syntax required for ambipolar reactions. Their reactants and products must be listed in specific order.</p>
<p>When creating particles, either by the <a class="reference internal" href="create_particles.html#command-create-particles"><span class="std std-ref">create_particles command</span></a> or <a class="reference internal" href="fix_emit_face.html#command-fix-emit-face"><span class="std std-ref">fix emit/face command</span></a> variants, do NOT use a mixture that includes the ambipolar electron species. If you do this, you will create “free” electrons which are not coupled to an ambipolar ion. You can include ambipolar ions in the mixture. This will create ambipolar ions along with their associated electron. The electron will be assigned a velocity consistent with its mass and the temperature of the created particles. You can use the <a class="reference internal" href="mixture.html#command-mixture"><span class="std std-ref">mixture copy</span></a> and <a class="reference internal" href="mixture.html#command-mixture"><span class="std std-ref">mixture delete</span></a> commands to create a mixture that excludes only the ambipolar electron species, e.g.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mixture</span> <span class="nb">all</span> <span class="n">copy</span> <span class="n">noElectron</span>
<span class="n">mixture</span> <span class="n">noElectron</span> <span class="n">delete</span> <span class="n">e</span>
</pre></div>
</div>
<p>If you want ambipolar ions to re-combine with their electrons when they collide with surfaces, use the <a class="reference internal" href="surf_react.html#command-surf-react"><span class="std std-ref">surf_react command</span></a> with an input file of surface reactions that includes recombination reactions like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">N</span><span class="o">+</span> <span class="o">+</span> <span class="n">e</span> <span class="o">-&gt;</span> <span class="n">N</span>
</pre></div>
</div>
<p>See the <cite>surf_react &lt;command-surf-react&gt;</cite> doc page for syntax details. A sample surface reaction data file is provided in data/air.surf. You assign the surface reaction model to surface or the simulation box boundaries via the <a class="reference internal" href="surf_modify.html#command-surf-modify"><span class="std std-ref">surf_modify command</span></a> and <cite>command-bound_modify</cite>.</p>
<p>For diagnositics and output, you can use the <a class="reference internal" href="compute_count.html#command-compute-count"><span class="std std-ref">compute count command</span></a> and <cite>command-dump-particle</cite>. The <a class="reference internal" href="compute_count.html#command-compute-count"><span class="std std-ref">compute count command</span></a> generate counts of individual species, entire mixtures, and groups within mixtures. For example these commands will include counts of ambipolar ions in statistical output:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">compute</span> <span class="n">myCount</span> <span class="n">O</span><span class="o">+</span> <span class="n">N</span><span class="o">+</span> <span class="n">NO</span><span class="o">+</span> <span class="n">e</span>
<span class="n">stats_style</span> <span class="n">step</span> <span class="n">nsreact</span> <span class="n">nsreactave</span> <span class="n">cpu</span> <span class="n">np</span> <span class="n">c_myCount</span>
</pre></div>
</div>
<p>Note that the count for species “e” = ambipolar electrons should alwas be zero, since those particles only exist during gas and surface collisions. The <a class="reference internal" href="stats_style.html#command-stats-style"><span class="std std-ref">stats_style</span></a> <em>nsreact</em> and <em>nsreactave</em> keywords print tallies of surface reactions taking place.</p>
<p>The <a class="reference internal" href="dump.html#command-dump"><span class="std std-ref">dump particle</span></a> command can output the custom particle
attributes defined by the <a class="reference internal" href="fix_ambipolar.html#command-fix-ambipolar"><span class="std std-ref">fix ambipolar command</span></a>. E.g. this command</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">dump</span> <span class="mi">1</span> <span class="n">particle</span> <span class="mi">1000</span> <span class="n">tmp</span><span class="o">.</span><span class="n">dump</span> <span class="nb">id</span> <span class="nb">type</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="n">p_ionambi</span> <span class="n">p_velambi</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
</pre></div>
</div>
<p>will output the ionambi flag = 1 for ambipolar ions, along with the vy
of their associated ambipolar electrons.</p>
<p>The <a class="reference internal" href="read_restart.html#command-read-restart"><span class="std std-ref">read_restart</span></a> doc page explains how to restart ambipolar simulations where a fix like <a class="reference internal" href="fix_ambipolar.html#command-fix-ambipolar"><span class="std std-ref">fix ambipolar</span></a> has been used to store extra per-particle properties.</p>
</div>
<div class="section" id="using-multiple-vibrational-energy-levels">
<h2><a class="toc-backref" href="#id13">6.12. Using multiple vibrational energy levels</a><a class="headerlink" href="#using-multiple-vibrational-energy-levels" title="Permalink to this headline">¶</a></h2>
<p>DSMC models for collisions between one or more polyatomic species can
include the effect of multiple discrete vibrational levels, where a
collision transfers vibrational energy not just between the two
particles in aggregate but between the various levels defined for each
particle species.</p>
<p>This kind of model can be enabled in SPARTA using the following
commands:</p>
<ul class="simple">
<li><p><a class="reference internal" href="species.html#command-species"><span class="std std-ref">species … vibfile …</span></a></p></li>
<li><p><a class="reference internal" href="collide_modify.html#command-collide-modify"><span class="std std-ref">collide_modify vibrate discrete</span></a></p></li>
<li><p><a class="reference internal" href="fix_vibmode.html#command-fix-vibmode"><span class="std std-ref">fix vibmode</span></a></p></li>
<li><p><a class="reference internal" href="dump.html#command-dump"><span class="std std-ref">dump particle p_vibmode</span></a></p></li>
</ul>
<p>The <a class="reference internal" href="species.html#command-species"><span class="std std-ref">species command</span></a> with its <em>vibfile</em> option allows a separate file with per-species vibrational information to be read. See data/air.species.vib for an example of such a file.</p>
<p>Only species with 4,6,8 vibrational degrees of freedom, as defined in the species file read by the <a class="reference internal" href="species.html#command-species"><span class="std std-ref">species command</span></a>, need to be listed in the <em>vibfile</em>. These species have N modes, where N = degrees of freedom / 2. For each mode, a vibrational temperature, relaxation number, and degeneracy is defined in the <em>vibfile</em>. These quantities are used in the energy exchange formulas for each collision.</p>
<p>The <a class="reference internal" href="collide_modify.html#command-collide-modify"><span class="std std-ref">collide_modify vibrate discrete</span></a> command is
used to enable the discrete model. Other allowed settings are <em>none</em> and
<em>smooth</em>. The former turns off vibrational energy effects altogether.
The latter uses a single continuous value to represent vibrational
energy; no per-mode information is used.</p>
<p>The <a class="reference internal" href="fix_vibmode.html#command-fix-vibmode"><span class="std std-ref">fix vibmode</span></a> command is used to allocate
per-particle storage for the population of levels appropriate to the
particle’s species. This will be from 1 to 4 values for each species.
Note that this command must be used before particles are created via the
<a class="reference internal" href="create_particles.html#command-create-particles"><span class="std std-ref">create_particles command</span></a> to allow the level
populations for new particles to be set appropriately. The <a class="reference internal" href="fix_vibmode.html#command-fix-vibmode"><span class="std std-ref">fix vibmode command</span></a> doc page has more details.</p>
<p>The <a class="reference internal" href="dump.html#command-dump"><span class="std std-ref">dump particle</span></a> command can output the custom particle attributes defined by the <a class="reference internal" href="fix_vibmode.html#command-fix-vibmode"><span class="std std-ref">fix vibmode</span></a> command.  E.g. this command</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">dump</span> <span class="mi">1</span> <span class="n">particle</span> <span class="mi">1000</span> <span class="n">tmp</span><span class="o">.</span><span class="n">dump</span> <span class="nb">id</span> <span class="nb">type</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="n">evib</span> <span class="n">p_vibmode</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="n">p_vibmode</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="n">p_vibmode</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
</pre></div>
</div>
<p>will output for each particle evib = total vibrational energy (summed across all levels), and the population counts for the first 3 vibrational energy levels. The vibmode count will be 0 for vibrational levels that do not exist for particles of a particular species.</p>
<p>The <a class="reference internal" href="read_restart.html#command-read-restart"><span class="std std-ref">read_restart</span></a> doc page explains how to restart simulations where a fix like <a class="reference internal" href="fix_vibmode.html#command-fix-vibmode"><span class="std std-ref">fix vibmode</span></a> has been used to store extra per-particle properties.</p>
</div>
<div class="section" id="surface-elements-explicit-implicit-distributed">
<span id="howto-surface-elements"></span><h2><a class="toc-backref" href="#id14">6.13. Surface elements: explicit, implicit, distributed</a><a class="headerlink" href="#surface-elements-explicit-implicit-distributed" title="Permalink to this headline">¶</a></h2>
<p>SPARTA can work with two kinds of surface elements: explicit and implicit. Explicit surfaces are lines (2d) or triangles (3d) defined in surface data files read by the <a class="reference internal" href="read_surf.html#command-read-surf"><span class="std std-ref">read_surf command</span></a>.  An individual element can be any size; a single surface element can intersect many grid cells. Implicit surfaces are lines (2d) or triangles (3d) defined by grid corner point data files read by the <a class="reference internal" href="read_isurf.html#command-read-isurf"><span class="std std-ref">read_isurf command</span></a>. The corner point values define lines or triangles that are wholly contained with single grid cells.</p>
<p>Note that you cannot mix explicit and implicit surfaces in the same simulation.</p>
<p>The data and attributes of explicit surface elements can be stored in one of two ways. The default is for each processor to store a copy of all the elements. Memory-wise, this is fine for most models. The other option is distributed, where each processor only stores copies of surface elements assigned to grid cells it owns or has a ghost copy of.  For models with huge numbers of surface elements, distributing them will use much less memory per processor. Note that a surface element requires about 150 bytes of storage, so storing a million requires about 150 MBytes.</p>
<p>Implicit surfaces are always stored in a distributed fashion. Each processor only stores a copy of surface elements assigned to grid cells it owns or has a ghost copy of. Note that 3d implicit surfs are not yet fully implemented. Specifically, the <a class="reference internal" href="read_isurf.html#command-read-isurf"><span class="std std-ref">read_isurf command</span></a> will not yet read and create them.</p>
<p>The <a class="reference internal" href="global.html#command-global"><span class="std std-ref">global surfs</span></a> command is used to specify the use of explicit versus implicit, and distributed versus non-distributed surface elements.</p>
<p>Unless noted, the following surface-related commands work with either explict or implicit surfaces, whether they are distributed or not. For large data sets, the read and write surf and isurf commands have options to use multiple files and/or operate in parallel which can reduce I/O times.</p>
<ul class="simple">
<li><p><a class="reference internal" href="adapt_grid.html#command-adapt-grid"><span class="std std-ref">adapt_grid</span></a></p></li>
<li><p><a class="reference internal" href="compute_isurf_grid.html#command-compute-isurf-grid"><span class="std std-ref">compute_isurf/grid</span></a> # for implicit surfs</p></li>
<li><p><a class="reference internal" href="compute_surf.html#command-compute-surf"><span class="std std-ref">compute_surf</span></a> # for explicit surfs</p></li>
<li><p><a class="reference internal" href="dump.html#command-dump"><span class="std std-ref">dump surf</span></a></p></li>
<li><p><a class="reference internal" href="dump_image.html#command-dump-image"><span class="std std-ref">dump image</span></a></p></li>
<li><p><a class="reference internal" href="fix_adapt.html#command-fix-adapt"><span class="std std-ref">fix adapt/grid</span></a></p></li>
<li><p><a class="reference internal" href="fix_emit_surf.html#command-fix-emit-surf"><span class="std std-ref">fix emit/surf</span></a></p></li>
<li><p><a class="reference internal" href="group.html#command-group"><span class="std std-ref">group surf</span></a></p></li>
<li><p><a class="reference internal" href="read_isurf.html#command-read-isurf"><span class="std std-ref">read_isurf</span></a> # for implicit surfs</p></li>
<li><p><a class="reference internal" href="read_surf.html#command-read-surf"><span class="std std-ref">read_surf</span></a> # for explicit surfs</p></li>
<li><p><a class="reference internal" href="surf_modify.html#command-surf-modify"><span class="std std-ref">surf_modify</span></a></p></li>
<li><p><a class="reference internal" href="write_surf.html#command-write-surf"><span class="std std-ref">write_isurf</span></a> # for implicit surfs</p></li>
<li><p><a class="reference internal" href="write_surf.html#command-write-surf"><span class="std std-ref">write_surf</span></a></p></li>
</ul>
<p>These command do not yet support distributed surfaces:</p>
<ul class="simple">
<li><p><a class="reference internal" href="move_surf.html#command-move-surf"><span class="std std-ref">move_surf</span></a></p></li>
<li><p><a class="reference internal" href="fix_move_surf.html#command-fix-move-surf"><span class="std std-ref">fix move/surf</span></a></p></li>
<li><p><a class="reference internal" href="remove_surf.html#command-remove-surf"><span class="std std-ref">remove_surf</span></a></p></li>
</ul>
</div>
<div class="section" id="implicit-surface-ablation">
<h2><a class="toc-backref" href="#id15">6.14. Implicit surface ablation</a><a class="headerlink" href="#implicit-surface-ablation" title="Permalink to this headline">¶</a></h2>
<p>The implicit surfaces described in the previous section can be used to
perform ablation simulations, where the set of implicit surface elements
evolve over time to model a receding surface. These are the relevant
commands:</p>
<ul class="simple">
<li><p><a class="reference internal" href="global.html#command-global"><span class="std std-ref">global surfs implicit</span></a></p></li>
<li><p><a class="reference internal" href="read_isurf.html#command-read-isurf"><span class="std std-ref">read isurf</span></a></p></li>
<li><p><a class="reference internal" href="fix_ablate.html#command-fix-ablate"><span class="std std-ref">fix ablate</span></a></p></li>
<li><p><a class="reference internal" href="compute_isurf_grid.html#command-compute-isurf-grid"><span class="std std-ref">compute isurf/grid</span></a></p></li>
<li><p><a class="reference internal" href="compute_react_isurf_grid.html#command-compute-react-isurf-grid"><span class="std std-ref">compute react/isurf/grid</span></a></p></li>
<li><p><a class="reference internal" href="fix_ave_grid.html#command-fix-ave-grid"><span class="std std-ref">fix ave/grid</span></a></p></li>
<li><p><a class="reference internal" href="write_isurf.html#command-write-isurf"><span class="std std-ref">write isurf</span></a></p></li>
<li><p><a class="reference internal" href="write_surf.html#command-write-surf"><span class="std std-ref">write_surf</span></a></p></li>
</ul>
<p>The <a class="reference internal" href="read_isurf.html#command-read-isurf"><span class="std std-ref">read_isurf command</span></a> takes a binary file as an argument which contains a pixelated (2d) or voxelated (3d) representation of the surface (e.g. a porous heat shield material). It reads the file and assigns the pixel/voxel values to corner points of a region of the SPARTA grid.</p>
<p>The <a class="reference internal" href="read_isurf.html#command-read-isurf"><span class="std std-ref">read_isurf command</span></a> also takes the ID of a <a class="reference internal" href="fix_ablate.html#command-fix-ablate"><span class="std std-ref">fix ablate command</span></a> command as an argument. This fix is invoked to perform a Marching Squares (2d) or Marching Cubes (3d) algorithm to convert the corner point values to a set of line segments (2d) or triangles (3d) each of which is wholly contained in a grid cell. It also stores the per grid cell corner point values.</p>
<p>If the <em>Nevery</em> argument of the <a class="reference internal" href="fix_ablate.html#command-fix-ablate"><span class="std std-ref">fix ablate command</span></a> is 0, ablation is never performed, the implicit surfaces are static. If it is non-zero, an ablation operation is performed every <em>Nevery</em> steps.  A per-grid cell value is used to decrement the corner point values in each grid cell. The values can be (1) from a compute such as <a class="reference internal" href="compute_isurf_grid.html#command-compute-isurf-grid"><span class="std std-ref">compute isurf/grid</span></a> which tallies statistics about gas particle collisions with surfaces within each grid cell. Or <a class="reference internal" href="compute_react_isurf_grid.html#command-compute-react-isurf-grid"><span class="std std-ref">compute react/isurf/grid</span></a> which tallies the number of surface reactions that take place. Or values can be (2) from a fix such as <cite>fix ave/grid &lt;command-fix-ave-grid&gt;</cite> which time averages these statistics over many timesteps. Or they can be (3) generated randomly, which is useful for debugging.</p>
<p>The decrement of grid corner point values is done in a manner that models recession of the surface elements within in each grid cell. All the current implicit surface elements are then discarded, and new ones are generated from the new corner point values via the Marching Squares or Marching Cubes algorithm.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Ideally these algorithms should preserve the gas flow volume inferred by the previous surfaces and only add to it with the new surfaces. However there are a few cases for the 3d Marching Cubes algorithm where the gas flow volume is not strictly preserved. This can trap existing particles inside the new surfaces. Currently SPARTA checks for this condition and deletes the trapped particles.
In the future, we plan to modify the standard Marching Cubes algorithm to prevent this from happening. In our testing, the fraction of trapped particles in an ablation operation is tiny (around 0.005% or 5 in 100000). The number of deleted particles can be monitored as an output option by the <a class="reference internal" href="fix_ablate.html#command-fix-ablate"><span class="std std-ref">fix ablate command</span></a>.</p>
</div>
<p>The <a class="reference internal" href="write_isurf.html#command-write-isurf"><span class="std std-ref">write_isurf command</span></a> can be used to periodically write out a pixelated/voxelated file of corner point values, in the same format that the <a class="reference internal" href="read_isurf.html#command-read-isurf"><span class="std std-ref">read_isurf command</span></a> reads. Note that after ablation, corner point values are typically no longer integers, but floating point values. The <a class="reference internal" href="read_isurf.html#command-read-isurf"><span class="std std-ref">read_isurf command</span></a> and <a class="reference internal" href="write_isurf.html#command-write-isurf"><span class="std std-ref">write_isurf command</span></a> have options to work with both kinds of files. The <a class="reference internal" href="write_surf.html#command-write-surf"><span class="std std-ref">write_surf command</span></a> can also output implicit surface elements for visualization by tools such as ParaView which can read SPARTA surface element files after suitable post-processing. See the <a class="reference internal" href="Section_tools.html#tools-paraview"><span class="std std-ref">Section tools paraview</span></a> doc page for more details.</p>
</div>
<div class="section" id="transparent-surface-elements">
<span id="howto-transparent-surface"></span><h2><a class="toc-backref" href="#id16">6.15. Transparent surface elements</a><a class="headerlink" href="#transparent-surface-elements" title="Permalink to this headline">¶</a></h2>
<p>Transparent surfaces are useful for tallying flow statistics. Particles pass through them unaffected. However the flux of particles through those surface elements can be tallied and output.</p>
<p>Transparent surfaces are treated differently than regular surfaces. They do not need to be watertight. E.g. you can define a set of line segments that form a straight (or curved) line in 2d. Or a set of triangle that form a plane (or curved surface) in 3d. You can define multiple such surfaces, e.g. multiple disjoint planes, and tally flow statistics through each of them. To tally or sum the statistics separately, you may want to assign the triangles in each plane to a different surface group via the <a class="reference internal" href="read_surf.html#command-read-surf"><span class="std std-ref">read_surf group</span></a> or <a class="reference internal" href="group.html#command-group"><span class="std std-ref">group surf</span></a> commands.</p>
<p>Note that for purposes of collisions, transparent surface elements are one-sided. A collision is only tallied for particles passing through the outward face of the element. If you want to tally particles passing through in both directions, then define 2 transparent surfaces, with opposite orientation. Again, you may want to put the 2 surfaces in separate groups.</p>
<p>There also should be no restriction on transparent surfaces intersecting each other or intersecting regular surfaces. Though there may be some corner cases we haven’t thought about or tested.</p>
<p>These are the relevant commands. See their doc pages for details:</p>
<ul class="simple">
<li><p><a class="reference internal" href="read_surf.html#command-read-surf"><span class="std std-ref">read_surf transparent</span></a></p></li>
<li><p><a class="reference internal" href="surf_collide.html#command-surf-collide"><span class="std std-ref">surf_collide transparent</span></a></p></li>
<li><p><a class="reference internal" href="compute_surf.html#command-compute-surf"><span class="std std-ref">compute surf</span></a></p></li>
</ul>
<p>The <a class="reference internal" href="read_surf.html#command-read-surf"><span class="std std-ref">read_surf command</span></a> with its <em>transparent</em> keyword is used to flag all the read-in surface elements as transparent.  This means they must be in a file separate from regular non-transparent elements.</p>
<p>The <a class="reference internal" href="surf_collide.html#command-surf-collide"><span class="std std-ref">surf_collide command</span></a> must be used with its <em>transparent</em> model and assigned to all transparent surface elements via the <a class="reference internal" href="surf_modify.html#command-surf-modify"><span class="std std-ref">surf_modify command</span></a>.</p>
<p>The <a class="reference internal" href="compute_surf.html#command-compute-surf"><span class="std std-ref">compute surf command</span></a> can be used to tally
the count, mass flux, and energy flux of particles that pass through
transparent surface elements. These quantities can then be time averaged
via the <a class="reference internal" href="fix_ave_surf.html#command-fix-ave-surf"><span class="std std-ref">fix ave/surf</span></a> command or output via the
<a class="reference internal" href="dump.html#command-dump"><span class="std std-ref">dump surf</span></a> command in the usual ways, as described
in <a class="reference internal" href="#howto-output"><span class="std std-ref">Section</span></a>.</p>
<p>The examples/circle/in.circle.transparent script shows how to use these commands when modeling flow around a 2d circle. Two additional transparent line segments are placed in front of the circle to tally particle count and kinetic energy flux in both directions in front of the object. These are defined in the data.plane1 and data.plane2 files.  The resulting tallies are output with the <a class="reference internal" href="stats_style.html#command-stats-style"><span class="std std-ref">stats_style command</span></a>. They could also be output with a <a class="reference internal" href="dump.html#command-dump"><span class="std std-ref">dump command</span></a> for more resolution if the 2 lines were each defined as multiple line segments.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="Section_example.html" class="btn btn-neutral float-right" title="7. Example problems" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="Section_accelerate.html" class="btn btn-neutral float-left" title="5. Accelerating SPARTA performance" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>